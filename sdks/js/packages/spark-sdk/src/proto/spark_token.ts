// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.2
//   protoc               v5.29.3
// source: spark_token.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { CallContext, CallOptions } from "nice-grpc-common";
import { Timestamp } from "./google/protobuf/timestamp.js";
import { Network, networkFromJSON, networkToJSON, SigningKeyshare } from "./spark.js";

export const protobufPackage = "spark_token";

/**
 * This proto is constructed by the wallet to specify leaves it wants to spend
 * as part of the token transaction.
 */
export interface TokenOutputToSpend {
  prevTokenTransactionHash: Uint8Array;
  prevTokenTransactionVout: number;
}

export interface TokenTransferInput {
  outputsToSpend: TokenOutputToSpend[];
}

export interface TokenMintInput {
  issuerPublicKey: Uint8Array;
  /**
   * Issuer provided timestamp of when the transaction was signed/constructed.
   * Helps provide idempotency and ensures that each mint input signature is
   * unique as long as multiple mint signatures are not happening at the same
   * time. Also gives a potentially useful data point for when the issuer
   * authorized from their perspective.  Note that we have no way of proving
   * this is accurate.
   * TODO: Consider whether implementing generic idempotency controls and/or a
   * random nonce would be favorable to populating this field.
   */
  issuerProvidedTimestamp: number;
}

/**
 * This proto is constructed by the wallet to specify outputs it wants to create
 * as part of a token transaction. Output id and revocation public key should
 * remain unfilled so that the SE can fill them as part of the
 * StartTokenTransaction() call.
 */
export interface TokenOutput {
  id?: string | undefined;
  ownerPublicKey: Uint8Array;
  revocationCommitment?: Uint8Array | undefined;
  withdrawBondSats?: number | undefined;
  withdrawRelativeBlockLocktime?: number | undefined;
  tokenPublicKey: Uint8Array;
  /** Decoded uint128 */
  tokenAmount: Uint8Array;
}

/**
 * This proto is constructed by the wallet and is the core transaction data
 * structure. This proto is deterministically hashed to generate the
 * token_transaction_hash that is cooperatively signed by the SO group to
 * confirm a token transaction.
 */
export interface TokenTransaction {
  /**
   * For mint transactions issuer_public_key will be specified without any
   * outputs_to_spend. For transfer transactions the token amount in the input
   * leaves must match the token amount in the output leaves.
   */
  version: number;
  tokenInputs?: { $case: "mintInput"; mintInput: TokenMintInput } | {
    $case: "transferInput";
    transferInput: TokenTransferInput;
  } | undefined;
  tokenOutputs: TokenOutput[];
  sparkOperatorIdentityPublicKeys: Uint8Array[];
  /**
   * Server-set expiry time. The server calculates this by adding the client's
   * requested validity_duration_seconds to the server's current time when
   * creating the final transaction.
   */
  expiryTime: Date | undefined;
  network: Network;
}

export interface SignatureWithIndex {
  /**
   * This is a Schnorr or ECDSA DER signature which can be between 64 and 73
   * bytes.
   */
  signature: Uint8Array;
  /** The index of the TTXO associated with this signature. */
  inputIndex: number;
}

/**
 * A group of signatures for the input TTXOs binding them to the final token
 * transaction hash. This bundle of signatures is specific to a given operator.
 */
export interface InputTtxoSignaturesPerOperator {
  ttxoSignatures: SignatureWithIndex[];
  operatorIdentityPublicKey: Uint8Array;
}

/** === Start Transaction === */
export interface StartTransactionRequest {
  identityPublicKey: Uint8Array;
  partialTokenTransaction:
    | TokenTransaction
    | undefined;
  /**
   * Filled by signing the partial token transaction hash with the
   * owner/issuer private key. For mint transactions this will be one
   * signature for the input issuer_public_key For transfer transactions this
   * will be one for each output for the output owner_public_key
   */
  partialTokenTransactionOwnerSignatures: SignatureWithIndex[];
  /**
   * How long the transaction should be valid for, in seconds.
   * The server will set the actual expiry_time in the final transaction based
   * on this duration. Must be between 1 and 300 seconds.
   */
  validityDurationSeconds: number;
}

export interface StartTransactionResponse {
  finalTokenTransaction: TokenTransaction | undefined;
  keyshareInfo: SigningKeyshare | undefined;
}

export interface CommitTransactionRequest {
  finalTokenTransaction: TokenTransaction | undefined;
  finalTokenTransactionHash: Uint8Array;
  inputTtxoSignaturesPerOperator: InputTtxoSignaturesPerOperator[];
  ownerIdentityPublicKey: Uint8Array;
}

export interface CommitTransactionResponse {
}

function createBaseTokenOutputToSpend(): TokenOutputToSpend {
  return { prevTokenTransactionHash: new Uint8Array(0), prevTokenTransactionVout: 0 };
}

export const TokenOutputToSpend: MessageFns<TokenOutputToSpend> = {
  encode(message: TokenOutputToSpend, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prevTokenTransactionHash.length !== 0) {
      writer.uint32(10).bytes(message.prevTokenTransactionHash);
    }
    if (message.prevTokenTransactionVout !== 0) {
      writer.uint32(16).uint32(message.prevTokenTransactionVout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenOutputToSpend {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenOutputToSpend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.prevTokenTransactionHash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.prevTokenTransactionVout = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenOutputToSpend {
    return {
      prevTokenTransactionHash: isSet(object.prevTokenTransactionHash)
        ? bytesFromBase64(object.prevTokenTransactionHash)
        : new Uint8Array(0),
      prevTokenTransactionVout: isSet(object.prevTokenTransactionVout)
        ? globalThis.Number(object.prevTokenTransactionVout)
        : 0,
    };
  },

  toJSON(message: TokenOutputToSpend): unknown {
    const obj: any = {};
    if (message.prevTokenTransactionHash.length !== 0) {
      obj.prevTokenTransactionHash = base64FromBytes(message.prevTokenTransactionHash);
    }
    if (message.prevTokenTransactionVout !== 0) {
      obj.prevTokenTransactionVout = Math.round(message.prevTokenTransactionVout);
    }
    return obj;
  },

  create(base?: DeepPartial<TokenOutputToSpend>): TokenOutputToSpend {
    return TokenOutputToSpend.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenOutputToSpend>): TokenOutputToSpend {
    const message = createBaseTokenOutputToSpend();
    message.prevTokenTransactionHash = object.prevTokenTransactionHash ?? new Uint8Array(0);
    message.prevTokenTransactionVout = object.prevTokenTransactionVout ?? 0;
    return message;
  },
};

function createBaseTokenTransferInput(): TokenTransferInput {
  return { outputsToSpend: [] };
}

export const TokenTransferInput: MessageFns<TokenTransferInput> = {
  encode(message: TokenTransferInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.outputsToSpend) {
      TokenOutputToSpend.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenTransferInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenTransferInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.outputsToSpend.push(TokenOutputToSpend.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenTransferInput {
    return {
      outputsToSpend: globalThis.Array.isArray(object?.outputsToSpend)
        ? object.outputsToSpend.map((e: any) => TokenOutputToSpend.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TokenTransferInput): unknown {
    const obj: any = {};
    if (message.outputsToSpend?.length) {
      obj.outputsToSpend = message.outputsToSpend.map((e) => TokenOutputToSpend.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TokenTransferInput>): TokenTransferInput {
    return TokenTransferInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenTransferInput>): TokenTransferInput {
    const message = createBaseTokenTransferInput();
    message.outputsToSpend = object.outputsToSpend?.map((e) => TokenOutputToSpend.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTokenMintInput(): TokenMintInput {
  return { issuerPublicKey: new Uint8Array(0), issuerProvidedTimestamp: 0 };
}

export const TokenMintInput: MessageFns<TokenMintInput> = {
  encode(message: TokenMintInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.issuerPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.issuerPublicKey);
    }
    if (message.issuerProvidedTimestamp !== 0) {
      writer.uint32(16).uint64(message.issuerProvidedTimestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenMintInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenMintInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.issuerPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.issuerProvidedTimestamp = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenMintInput {
    return {
      issuerPublicKey: isSet(object.issuerPublicKey) ? bytesFromBase64(object.issuerPublicKey) : new Uint8Array(0),
      issuerProvidedTimestamp: isSet(object.issuerProvidedTimestamp)
        ? globalThis.Number(object.issuerProvidedTimestamp)
        : 0,
    };
  },

  toJSON(message: TokenMintInput): unknown {
    const obj: any = {};
    if (message.issuerPublicKey.length !== 0) {
      obj.issuerPublicKey = base64FromBytes(message.issuerPublicKey);
    }
    if (message.issuerProvidedTimestamp !== 0) {
      obj.issuerProvidedTimestamp = Math.round(message.issuerProvidedTimestamp);
    }
    return obj;
  },

  create(base?: DeepPartial<TokenMintInput>): TokenMintInput {
    return TokenMintInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenMintInput>): TokenMintInput {
    const message = createBaseTokenMintInput();
    message.issuerPublicKey = object.issuerPublicKey ?? new Uint8Array(0);
    message.issuerProvidedTimestamp = object.issuerProvidedTimestamp ?? 0;
    return message;
  },
};

function createBaseTokenOutput(): TokenOutput {
  return {
    id: undefined,
    ownerPublicKey: new Uint8Array(0),
    revocationCommitment: undefined,
    withdrawBondSats: undefined,
    withdrawRelativeBlockLocktime: undefined,
    tokenPublicKey: new Uint8Array(0),
    tokenAmount: new Uint8Array(0),
  };
}

export const TokenOutput: MessageFns<TokenOutput> = {
  encode(message: TokenOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      writer.uint32(10).string(message.id);
    }
    if (message.ownerPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.ownerPublicKey);
    }
    if (message.revocationCommitment !== undefined) {
      writer.uint32(26).bytes(message.revocationCommitment);
    }
    if (message.withdrawBondSats !== undefined) {
      writer.uint32(32).uint64(message.withdrawBondSats);
    }
    if (message.withdrawRelativeBlockLocktime !== undefined) {
      writer.uint32(40).uint64(message.withdrawRelativeBlockLocktime);
    }
    if (message.tokenPublicKey.length !== 0) {
      writer.uint32(50).bytes(message.tokenPublicKey);
    }
    if (message.tokenAmount.length !== 0) {
      writer.uint32(58).bytes(message.tokenAmount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.revocationCommitment = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.withdrawBondSats = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.withdrawRelativeBlockLocktime = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tokenPublicKey = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tokenAmount = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenOutput {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : undefined,
      ownerPublicKey: isSet(object.ownerPublicKey) ? bytesFromBase64(object.ownerPublicKey) : new Uint8Array(0),
      revocationCommitment: isSet(object.revocationCommitment)
        ? bytesFromBase64(object.revocationCommitment)
        : undefined,
      withdrawBondSats: isSet(object.withdrawBondSats) ? globalThis.Number(object.withdrawBondSats) : undefined,
      withdrawRelativeBlockLocktime: isSet(object.withdrawRelativeBlockLocktime)
        ? globalThis.Number(object.withdrawRelativeBlockLocktime)
        : undefined,
      tokenPublicKey: isSet(object.tokenPublicKey) ? bytesFromBase64(object.tokenPublicKey) : new Uint8Array(0),
      tokenAmount: isSet(object.tokenAmount) ? bytesFromBase64(object.tokenAmount) : new Uint8Array(0),
    };
  },

  toJSON(message: TokenOutput): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.ownerPublicKey.length !== 0) {
      obj.ownerPublicKey = base64FromBytes(message.ownerPublicKey);
    }
    if (message.revocationCommitment !== undefined) {
      obj.revocationCommitment = base64FromBytes(message.revocationCommitment);
    }
    if (message.withdrawBondSats !== undefined) {
      obj.withdrawBondSats = Math.round(message.withdrawBondSats);
    }
    if (message.withdrawRelativeBlockLocktime !== undefined) {
      obj.withdrawRelativeBlockLocktime = Math.round(message.withdrawRelativeBlockLocktime);
    }
    if (message.tokenPublicKey.length !== 0) {
      obj.tokenPublicKey = base64FromBytes(message.tokenPublicKey);
    }
    if (message.tokenAmount.length !== 0) {
      obj.tokenAmount = base64FromBytes(message.tokenAmount);
    }
    return obj;
  },

  create(base?: DeepPartial<TokenOutput>): TokenOutput {
    return TokenOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenOutput>): TokenOutput {
    const message = createBaseTokenOutput();
    message.id = object.id ?? undefined;
    message.ownerPublicKey = object.ownerPublicKey ?? new Uint8Array(0);
    message.revocationCommitment = object.revocationCommitment ?? undefined;
    message.withdrawBondSats = object.withdrawBondSats ?? undefined;
    message.withdrawRelativeBlockLocktime = object.withdrawRelativeBlockLocktime ?? undefined;
    message.tokenPublicKey = object.tokenPublicKey ?? new Uint8Array(0);
    message.tokenAmount = object.tokenAmount ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTokenTransaction(): TokenTransaction {
  return {
    version: 0,
    tokenInputs: undefined,
    tokenOutputs: [],
    sparkOperatorIdentityPublicKeys: [],
    expiryTime: undefined,
    network: 0,
  };
}

export const TokenTransaction: MessageFns<TokenTransaction> = {
  encode(message: TokenTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).uint32(message.version);
    }
    switch (message.tokenInputs?.$case) {
      case "mintInput":
        TokenMintInput.encode(message.tokenInputs.mintInput, writer.uint32(18).fork()).join();
        break;
      case "transferInput":
        TokenTransferInput.encode(message.tokenInputs.transferInput, writer.uint32(26).fork()).join();
        break;
    }
    for (const v of message.tokenOutputs) {
      TokenOutput.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.sparkOperatorIdentityPublicKeys) {
      writer.uint32(42).bytes(v!);
    }
    if (message.expiryTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expiryTime), writer.uint32(50).fork()).join();
    }
    if (message.network !== 0) {
      writer.uint32(56).int32(message.network);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenInputs = { $case: "mintInput", mintInput: TokenMintInput.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenInputs = {
            $case: "transferInput",
            transferInput: TokenTransferInput.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tokenOutputs.push(TokenOutput.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sparkOperatorIdentityPublicKeys.push(reader.bytes());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.expiryTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.network = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenTransaction {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      tokenInputs: isSet(object.mintInput)
        ? { $case: "mintInput", mintInput: TokenMintInput.fromJSON(object.mintInput) }
        : isSet(object.transferInput)
        ? { $case: "transferInput", transferInput: TokenTransferInput.fromJSON(object.transferInput) }
        : undefined,
      tokenOutputs: globalThis.Array.isArray(object?.tokenOutputs)
        ? object.tokenOutputs.map((e: any) => TokenOutput.fromJSON(e))
        : [],
      sparkOperatorIdentityPublicKeys: globalThis.Array.isArray(object?.sparkOperatorIdentityPublicKeys)
        ? object.sparkOperatorIdentityPublicKeys.map((e: any) => bytesFromBase64(e))
        : [],
      expiryTime: isSet(object.expiryTime) ? fromJsonTimestamp(object.expiryTime) : undefined,
      network: isSet(object.network) ? networkFromJSON(object.network) : 0,
    };
  },

  toJSON(message: TokenTransaction): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.tokenInputs?.$case === "mintInput") {
      obj.mintInput = TokenMintInput.toJSON(message.tokenInputs.mintInput);
    } else if (message.tokenInputs?.$case === "transferInput") {
      obj.transferInput = TokenTransferInput.toJSON(message.tokenInputs.transferInput);
    }
    if (message.tokenOutputs?.length) {
      obj.tokenOutputs = message.tokenOutputs.map((e) => TokenOutput.toJSON(e));
    }
    if (message.sparkOperatorIdentityPublicKeys?.length) {
      obj.sparkOperatorIdentityPublicKeys = message.sparkOperatorIdentityPublicKeys.map((e) => base64FromBytes(e));
    }
    if (message.expiryTime !== undefined) {
      obj.expiryTime = message.expiryTime.toISOString();
    }
    if (message.network !== 0) {
      obj.network = networkToJSON(message.network);
    }
    return obj;
  },

  create(base?: DeepPartial<TokenTransaction>): TokenTransaction {
    return TokenTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenTransaction>): TokenTransaction {
    const message = createBaseTokenTransaction();
    message.version = object.version ?? 0;
    switch (object.tokenInputs?.$case) {
      case "mintInput": {
        if (object.tokenInputs?.mintInput !== undefined && object.tokenInputs?.mintInput !== null) {
          message.tokenInputs = {
            $case: "mintInput",
            mintInput: TokenMintInput.fromPartial(object.tokenInputs.mintInput),
          };
        }
        break;
      }
      case "transferInput": {
        if (object.tokenInputs?.transferInput !== undefined && object.tokenInputs?.transferInput !== null) {
          message.tokenInputs = {
            $case: "transferInput",
            transferInput: TokenTransferInput.fromPartial(object.tokenInputs.transferInput),
          };
        }
        break;
      }
    }
    message.tokenOutputs = object.tokenOutputs?.map((e) => TokenOutput.fromPartial(e)) || [];
    message.sparkOperatorIdentityPublicKeys = object.sparkOperatorIdentityPublicKeys?.map((e) => e) || [];
    message.expiryTime = object.expiryTime ?? undefined;
    message.network = object.network ?? 0;
    return message;
  },
};

function createBaseSignatureWithIndex(): SignatureWithIndex {
  return { signature: new Uint8Array(0), inputIndex: 0 };
}

export const SignatureWithIndex: MessageFns<SignatureWithIndex> = {
  encode(message: SignatureWithIndex, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signature.length !== 0) {
      writer.uint32(10).bytes(message.signature);
    }
    if (message.inputIndex !== 0) {
      writer.uint32(16).uint32(message.inputIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignatureWithIndex {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignatureWithIndex();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.inputIndex = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignatureWithIndex {
    return {
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
      inputIndex: isSet(object.inputIndex) ? globalThis.Number(object.inputIndex) : 0,
    };
  },

  toJSON(message: SignatureWithIndex): unknown {
    const obj: any = {};
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.inputIndex !== 0) {
      obj.inputIndex = Math.round(message.inputIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<SignatureWithIndex>): SignatureWithIndex {
    return SignatureWithIndex.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignatureWithIndex>): SignatureWithIndex {
    const message = createBaseSignatureWithIndex();
    message.signature = object.signature ?? new Uint8Array(0);
    message.inputIndex = object.inputIndex ?? 0;
    return message;
  },
};

function createBaseInputTtxoSignaturesPerOperator(): InputTtxoSignaturesPerOperator {
  return { ttxoSignatures: [], operatorIdentityPublicKey: new Uint8Array(0) };
}

export const InputTtxoSignaturesPerOperator: MessageFns<InputTtxoSignaturesPerOperator> = {
  encode(message: InputTtxoSignaturesPerOperator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ttxoSignatures) {
      SignatureWithIndex.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.operatorIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.operatorIdentityPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputTtxoSignaturesPerOperator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputTtxoSignaturesPerOperator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ttxoSignatures.push(SignatureWithIndex.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.operatorIdentityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputTtxoSignaturesPerOperator {
    return {
      ttxoSignatures: globalThis.Array.isArray(object?.ttxoSignatures)
        ? object.ttxoSignatures.map((e: any) => SignatureWithIndex.fromJSON(e))
        : [],
      operatorIdentityPublicKey: isSet(object.operatorIdentityPublicKey)
        ? bytesFromBase64(object.operatorIdentityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: InputTtxoSignaturesPerOperator): unknown {
    const obj: any = {};
    if (message.ttxoSignatures?.length) {
      obj.ttxoSignatures = message.ttxoSignatures.map((e) => SignatureWithIndex.toJSON(e));
    }
    if (message.operatorIdentityPublicKey.length !== 0) {
      obj.operatorIdentityPublicKey = base64FromBytes(message.operatorIdentityPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<InputTtxoSignaturesPerOperator>): InputTtxoSignaturesPerOperator {
    return InputTtxoSignaturesPerOperator.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InputTtxoSignaturesPerOperator>): InputTtxoSignaturesPerOperator {
    const message = createBaseInputTtxoSignaturesPerOperator();
    message.ttxoSignatures = object.ttxoSignatures?.map((e) => SignatureWithIndex.fromPartial(e)) || [];
    message.operatorIdentityPublicKey = object.operatorIdentityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseStartTransactionRequest(): StartTransactionRequest {
  return {
    identityPublicKey: new Uint8Array(0),
    partialTokenTransaction: undefined,
    partialTokenTransactionOwnerSignatures: [],
    validityDurationSeconds: 0,
  };
}

export const StartTransactionRequest: MessageFns<StartTransactionRequest> = {
  encode(message: StartTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identityPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.identityPublicKey);
    }
    if (message.partialTokenTransaction !== undefined) {
      TokenTransaction.encode(message.partialTokenTransaction, writer.uint32(18).fork()).join();
    }
    for (const v of message.partialTokenTransactionOwnerSignatures) {
      SignatureWithIndex.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.validityDurationSeconds !== 0) {
      writer.uint32(32).uint64(message.validityDurationSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identityPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.partialTokenTransaction = TokenTransaction.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.partialTokenTransactionOwnerSignatures.push(SignatureWithIndex.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.validityDurationSeconds = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartTransactionRequest {
    return {
      identityPublicKey: isSet(object.identityPublicKey)
        ? bytesFromBase64(object.identityPublicKey)
        : new Uint8Array(0),
      partialTokenTransaction: isSet(object.partialTokenTransaction)
        ? TokenTransaction.fromJSON(object.partialTokenTransaction)
        : undefined,
      partialTokenTransactionOwnerSignatures: globalThis.Array.isArray(object?.partialTokenTransactionOwnerSignatures)
        ? object.partialTokenTransactionOwnerSignatures.map((e: any) => SignatureWithIndex.fromJSON(e))
        : [],
      validityDurationSeconds: isSet(object.validityDurationSeconds)
        ? globalThis.Number(object.validityDurationSeconds)
        : 0,
    };
  },

  toJSON(message: StartTransactionRequest): unknown {
    const obj: any = {};
    if (message.identityPublicKey.length !== 0) {
      obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
    }
    if (message.partialTokenTransaction !== undefined) {
      obj.partialTokenTransaction = TokenTransaction.toJSON(message.partialTokenTransaction);
    }
    if (message.partialTokenTransactionOwnerSignatures?.length) {
      obj.partialTokenTransactionOwnerSignatures = message.partialTokenTransactionOwnerSignatures.map((e) =>
        SignatureWithIndex.toJSON(e)
      );
    }
    if (message.validityDurationSeconds !== 0) {
      obj.validityDurationSeconds = Math.round(message.validityDurationSeconds);
    }
    return obj;
  },

  create(base?: DeepPartial<StartTransactionRequest>): StartTransactionRequest {
    return StartTransactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartTransactionRequest>): StartTransactionRequest {
    const message = createBaseStartTransactionRequest();
    message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
    message.partialTokenTransaction =
      (object.partialTokenTransaction !== undefined && object.partialTokenTransaction !== null)
        ? TokenTransaction.fromPartial(object.partialTokenTransaction)
        : undefined;
    message.partialTokenTransactionOwnerSignatures =
      object.partialTokenTransactionOwnerSignatures?.map((e) => SignatureWithIndex.fromPartial(e)) || [];
    message.validityDurationSeconds = object.validityDurationSeconds ?? 0;
    return message;
  },
};

function createBaseStartTransactionResponse(): StartTransactionResponse {
  return { finalTokenTransaction: undefined, keyshareInfo: undefined };
}

export const StartTransactionResponse: MessageFns<StartTransactionResponse> = {
  encode(message: StartTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.finalTokenTransaction !== undefined) {
      TokenTransaction.encode(message.finalTokenTransaction, writer.uint32(10).fork()).join();
    }
    if (message.keyshareInfo !== undefined) {
      SigningKeyshare.encode(message.keyshareInfo, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.finalTokenTransaction = TokenTransaction.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keyshareInfo = SigningKeyshare.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartTransactionResponse {
    return {
      finalTokenTransaction: isSet(object.finalTokenTransaction)
        ? TokenTransaction.fromJSON(object.finalTokenTransaction)
        : undefined,
      keyshareInfo: isSet(object.keyshareInfo) ? SigningKeyshare.fromJSON(object.keyshareInfo) : undefined,
    };
  },

  toJSON(message: StartTransactionResponse): unknown {
    const obj: any = {};
    if (message.finalTokenTransaction !== undefined) {
      obj.finalTokenTransaction = TokenTransaction.toJSON(message.finalTokenTransaction);
    }
    if (message.keyshareInfo !== undefined) {
      obj.keyshareInfo = SigningKeyshare.toJSON(message.keyshareInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<StartTransactionResponse>): StartTransactionResponse {
    return StartTransactionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartTransactionResponse>): StartTransactionResponse {
    const message = createBaseStartTransactionResponse();
    message.finalTokenTransaction =
      (object.finalTokenTransaction !== undefined && object.finalTokenTransaction !== null)
        ? TokenTransaction.fromPartial(object.finalTokenTransaction)
        : undefined;
    message.keyshareInfo = (object.keyshareInfo !== undefined && object.keyshareInfo !== null)
      ? SigningKeyshare.fromPartial(object.keyshareInfo)
      : undefined;
    return message;
  },
};

function createBaseCommitTransactionRequest(): CommitTransactionRequest {
  return {
    finalTokenTransaction: undefined,
    finalTokenTransactionHash: new Uint8Array(0),
    inputTtxoSignaturesPerOperator: [],
    ownerIdentityPublicKey: new Uint8Array(0),
  };
}

export const CommitTransactionRequest: MessageFns<CommitTransactionRequest> = {
  encode(message: CommitTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.finalTokenTransaction !== undefined) {
      TokenTransaction.encode(message.finalTokenTransaction, writer.uint32(10).fork()).join();
    }
    if (message.finalTokenTransactionHash.length !== 0) {
      writer.uint32(18).bytes(message.finalTokenTransactionHash);
    }
    for (const v of message.inputTtxoSignaturesPerOperator) {
      InputTtxoSignaturesPerOperator.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(34).bytes(message.ownerIdentityPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.finalTokenTransaction = TokenTransaction.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.finalTokenTransactionHash = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputTtxoSignaturesPerOperator.push(InputTtxoSignaturesPerOperator.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitTransactionRequest {
    return {
      finalTokenTransaction: isSet(object.finalTokenTransaction)
        ? TokenTransaction.fromJSON(object.finalTokenTransaction)
        : undefined,
      finalTokenTransactionHash: isSet(object.finalTokenTransactionHash)
        ? bytesFromBase64(object.finalTokenTransactionHash)
        : new Uint8Array(0),
      inputTtxoSignaturesPerOperator: globalThis.Array.isArray(object?.inputTtxoSignaturesPerOperator)
        ? object.inputTtxoSignaturesPerOperator.map((e: any) => InputTtxoSignaturesPerOperator.fromJSON(e))
        : [],
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: CommitTransactionRequest): unknown {
    const obj: any = {};
    if (message.finalTokenTransaction !== undefined) {
      obj.finalTokenTransaction = TokenTransaction.toJSON(message.finalTokenTransaction);
    }
    if (message.finalTokenTransactionHash.length !== 0) {
      obj.finalTokenTransactionHash = base64FromBytes(message.finalTokenTransactionHash);
    }
    if (message.inputTtxoSignaturesPerOperator?.length) {
      obj.inputTtxoSignaturesPerOperator = message.inputTtxoSignaturesPerOperator.map((e) =>
        InputTtxoSignaturesPerOperator.toJSON(e)
      );
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<CommitTransactionRequest>): CommitTransactionRequest {
    return CommitTransactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommitTransactionRequest>): CommitTransactionRequest {
    const message = createBaseCommitTransactionRequest();
    message.finalTokenTransaction =
      (object.finalTokenTransaction !== undefined && object.finalTokenTransaction !== null)
        ? TokenTransaction.fromPartial(object.finalTokenTransaction)
        : undefined;
    message.finalTokenTransactionHash = object.finalTokenTransactionHash ?? new Uint8Array(0);
    message.inputTtxoSignaturesPerOperator =
      object.inputTtxoSignaturesPerOperator?.map((e) => InputTtxoSignaturesPerOperator.fromPartial(e)) || [];
    message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCommitTransactionResponse(): CommitTransactionResponse {
  return {};
}

export const CommitTransactionResponse: MessageFns<CommitTransactionResponse> = {
  encode(_: CommitTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CommitTransactionResponse {
    return {};
  },

  toJSON(_: CommitTransactionResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CommitTransactionResponse>): CommitTransactionResponse {
    return CommitTransactionResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CommitTransactionResponse>): CommitTransactionResponse {
    const message = createBaseCommitTransactionResponse();
    return message;
  },
};

export type SparkTokenServiceDefinition = typeof SparkTokenServiceDefinition;
export const SparkTokenServiceDefinition = {
  name: "SparkTokenService",
  fullName: "spark_token.SparkTokenService",
  methods: {
    /**
     * Start process to create final token transaction with all inputs required
     * from user and SOs (including revocation secret commitment)
     */
    start_transaction: {
      name: "start_transaction",
      requestType: StartTransactionRequest,
      requestStream: false,
      responseType: StartTransactionResponse,
      responseStream: false,
      options: {},
    },
    /**
     * Complete the transaction and commit it with all SOs. This will be
     * coordinated by one SO.
     */
    commit_transaction: {
      name: "commit_transaction",
      requestType: CommitTransactionRequest,
      requestStream: false,
      responseType: CommitTransactionResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface SparkTokenServiceImplementation<CallContextExt = {}> {
  /**
   * Start process to create final token transaction with all inputs required
   * from user and SOs (including revocation secret commitment)
   */
  start_transaction(
    request: StartTransactionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<StartTransactionResponse>>;
  /**
   * Complete the transaction and commit it with all SOs. This will be
   * coordinated by one SO.
   */
  commit_transaction(
    request: CommitTransactionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CommitTransactionResponse>>;
}

export interface SparkTokenServiceClient<CallOptionsExt = {}> {
  /**
   * Start process to create final token transaction with all inputs required
   * from user and SOs (including revocation secret commitment)
   */
  start_transaction(
    request: DeepPartial<StartTransactionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<StartTransactionResponse>;
  /**
   * Complete the transaction and commit it with all SOs. This will be
   * coordinated by one SO.
   */
  commit_transaction(
    request: DeepPartial<CommitTransactionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CommitTransactionResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
