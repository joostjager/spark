// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.29.3
// source: spark_token.proto

package spark_token

import (
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	spark "github.com/lightsparkdev/spark/proto/spark"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This proto is constructed by the wallet to specify leaves it wants to spend
// as part of the token transaction.
type TokenOutputToSpend struct {
	state                    protoimpl.MessageState `protogen:"open.v1"`
	PrevTokenTransactionHash []byte                 `protobuf:"bytes,1,opt,name=prev_token_transaction_hash,json=prevTokenTransactionHash,proto3" json:"prev_token_transaction_hash,omitempty"`
	PrevTokenTransactionVout uint32                 `protobuf:"varint,2,opt,name=prev_token_transaction_vout,json=prevTokenTransactionVout,proto3" json:"prev_token_transaction_vout,omitempty"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *TokenOutputToSpend) Reset() {
	*x = TokenOutputToSpend{}
	mi := &file_spark_token_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenOutputToSpend) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenOutputToSpend) ProtoMessage() {}

func (x *TokenOutputToSpend) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenOutputToSpend.ProtoReflect.Descriptor instead.
func (*TokenOutputToSpend) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{0}
}

func (x *TokenOutputToSpend) GetPrevTokenTransactionHash() []byte {
	if x != nil {
		return x.PrevTokenTransactionHash
	}
	return nil
}

func (x *TokenOutputToSpend) GetPrevTokenTransactionVout() uint32 {
	if x != nil {
		return x.PrevTokenTransactionVout
	}
	return 0
}

type TokenTransferInput struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	OutputsToSpend []*TokenOutputToSpend  `protobuf:"bytes,1,rep,name=outputs_to_spend,json=outputsToSpend,proto3" json:"outputs_to_spend,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *TokenTransferInput) Reset() {
	*x = TokenTransferInput{}
	mi := &file_spark_token_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenTransferInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenTransferInput) ProtoMessage() {}

func (x *TokenTransferInput) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenTransferInput.ProtoReflect.Descriptor instead.
func (*TokenTransferInput) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{1}
}

func (x *TokenTransferInput) GetOutputsToSpend() []*TokenOutputToSpend {
	if x != nil {
		return x.OutputsToSpend
	}
	return nil
}

type TokenMintInput struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	IssuerPublicKey []byte                 `protobuf:"bytes,1,opt,name=issuer_public_key,json=issuerPublicKey,proto3" json:"issuer_public_key,omitempty"`
	// Issuer provided timestamp of when the transaction was signed/constructed.
	// Helps provide idempotency and ensures that each mint input signature is
	// unique as long as multiple mint signatures are not happening at the same
	// time. Also gives a potentially useful data point for when the issuer
	// authorized from their perspective.  Note that we have no way of proving
	// this is accurate.
	// TODO: Consider whether implementing generic idempotency controls and/or a
	// random nonce would be favorable to populating this field.
	IssuerProvidedTimestamp uint64 `protobuf:"varint,2,opt,name=issuer_provided_timestamp,json=issuerProvidedTimestamp,proto3" json:"issuer_provided_timestamp,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *TokenMintInput) Reset() {
	*x = TokenMintInput{}
	mi := &file_spark_token_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenMintInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenMintInput) ProtoMessage() {}

func (x *TokenMintInput) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenMintInput.ProtoReflect.Descriptor instead.
func (*TokenMintInput) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{2}
}

func (x *TokenMintInput) GetIssuerPublicKey() []byte {
	if x != nil {
		return x.IssuerPublicKey
	}
	return nil
}

func (x *TokenMintInput) GetIssuerProvidedTimestamp() uint64 {
	if x != nil {
		return x.IssuerProvidedTimestamp
	}
	return 0
}

// This proto is constructed by the wallet to specify outputs it wants to create
// as part of a token transaction. Output id and revocation public key should
// remain unfilled so that the SE can fill them as part of the
// StartTokenTransaction() call.
type TokenOutput struct {
	state                         protoimpl.MessageState `protogen:"open.v1"`
	Id                            *string                `protobuf:"bytes,1,opt,name=id,proto3,oneof" json:"id,omitempty"`
	OwnerPublicKey                []byte                 `protobuf:"bytes,2,opt,name=owner_public_key,json=ownerPublicKey,proto3" json:"owner_public_key,omitempty"`
	RevocationCommitment          []byte                 `protobuf:"bytes,3,opt,name=revocation_commitment,json=revocationCommitment,proto3,oneof" json:"revocation_commitment,omitempty"`
	WithdrawBondSats              *uint64                `protobuf:"varint,4,opt,name=withdraw_bond_sats,json=withdrawBondSats,proto3,oneof" json:"withdraw_bond_sats,omitempty"`
	WithdrawRelativeBlockLocktime *uint64                `protobuf:"varint,5,opt,name=withdraw_relative_block_locktime,json=withdrawRelativeBlockLocktime,proto3,oneof" json:"withdraw_relative_block_locktime,omitempty"`
	TokenPublicKey                []byte                 `protobuf:"bytes,6,opt,name=token_public_key,json=tokenPublicKey,proto3" json:"token_public_key,omitempty"`
	TokenAmount                   []byte                 `protobuf:"bytes,7,opt,name=token_amount,json=tokenAmount,proto3" json:"token_amount,omitempty"` // Decoded uint128
	unknownFields                 protoimpl.UnknownFields
	sizeCache                     protoimpl.SizeCache
}

func (x *TokenOutput) Reset() {
	*x = TokenOutput{}
	mi := &file_spark_token_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenOutput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenOutput) ProtoMessage() {}

func (x *TokenOutput) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenOutput.ProtoReflect.Descriptor instead.
func (*TokenOutput) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{3}
}

func (x *TokenOutput) GetId() string {
	if x != nil && x.Id != nil {
		return *x.Id
	}
	return ""
}

func (x *TokenOutput) GetOwnerPublicKey() []byte {
	if x != nil {
		return x.OwnerPublicKey
	}
	return nil
}

func (x *TokenOutput) GetRevocationCommitment() []byte {
	if x != nil {
		return x.RevocationCommitment
	}
	return nil
}

func (x *TokenOutput) GetWithdrawBondSats() uint64 {
	if x != nil && x.WithdrawBondSats != nil {
		return *x.WithdrawBondSats
	}
	return 0
}

func (x *TokenOutput) GetWithdrawRelativeBlockLocktime() uint64 {
	if x != nil && x.WithdrawRelativeBlockLocktime != nil {
		return *x.WithdrawRelativeBlockLocktime
	}
	return 0
}

func (x *TokenOutput) GetTokenPublicKey() []byte {
	if x != nil {
		return x.TokenPublicKey
	}
	return nil
}

func (x *TokenOutput) GetTokenAmount() []byte {
	if x != nil {
		return x.TokenAmount
	}
	return nil
}

// This proto is constructed by the wallet and is the core transaction data
// structure. This proto is deterministically hashed to generate the
// token_transaction_hash that is cooperatively signed by the SO group to
// confirm a token transaction.
type TokenTransaction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// For mint transactions issuer_public_key will be specified without any
	// outputs_to_spend. For transfer transactions the token amount in the input
	// leaves must match the token amount in the output leaves.
	Version uint32 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	// Types that are valid to be assigned to TokenInputs:
	//
	//	*TokenTransaction_MintInput
	//	*TokenTransaction_TransferInput
	TokenInputs                     isTokenTransaction_TokenInputs `protobuf_oneof:"token_inputs"`
	TokenOutputs                    []*TokenOutput                 `protobuf:"bytes,4,rep,name=token_outputs,json=tokenOutputs,proto3" json:"token_outputs,omitempty"`
	SparkOperatorIdentityPublicKeys [][]byte                       `protobuf:"bytes,5,rep,name=spark_operator_identity_public_keys,json=sparkOperatorIdentityPublicKeys,proto3" json:"spark_operator_identity_public_keys,omitempty"`
	// Server-set expiry time. The server calculates this by adding the client's
	// requested validity_duration_seconds to the server's current time when
	// creating the final transaction.
	ExpiryTime    *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=expiry_time,json=expiryTime,proto3" json:"expiry_time,omitempty"`
	Network       spark.Network          `protobuf:"varint,7,opt,name=network,proto3,enum=spark.Network" json:"network,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TokenTransaction) Reset() {
	*x = TokenTransaction{}
	mi := &file_spark_token_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenTransaction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenTransaction) ProtoMessage() {}

func (x *TokenTransaction) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenTransaction.ProtoReflect.Descriptor instead.
func (*TokenTransaction) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{4}
}

func (x *TokenTransaction) GetVersion() uint32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *TokenTransaction) GetTokenInputs() isTokenTransaction_TokenInputs {
	if x != nil {
		return x.TokenInputs
	}
	return nil
}

func (x *TokenTransaction) GetMintInput() *TokenMintInput {
	if x != nil {
		if x, ok := x.TokenInputs.(*TokenTransaction_MintInput); ok {
			return x.MintInput
		}
	}
	return nil
}

func (x *TokenTransaction) GetTransferInput() *TokenTransferInput {
	if x != nil {
		if x, ok := x.TokenInputs.(*TokenTransaction_TransferInput); ok {
			return x.TransferInput
		}
	}
	return nil
}

func (x *TokenTransaction) GetTokenOutputs() []*TokenOutput {
	if x != nil {
		return x.TokenOutputs
	}
	return nil
}

func (x *TokenTransaction) GetSparkOperatorIdentityPublicKeys() [][]byte {
	if x != nil {
		return x.SparkOperatorIdentityPublicKeys
	}
	return nil
}

func (x *TokenTransaction) GetExpiryTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ExpiryTime
	}
	return nil
}

func (x *TokenTransaction) GetNetwork() spark.Network {
	if x != nil {
		return x.Network
	}
	return spark.Network(0)
}

type isTokenTransaction_TokenInputs interface {
	isTokenTransaction_TokenInputs()
}

type TokenTransaction_MintInput struct {
	MintInput *TokenMintInput `protobuf:"bytes,2,opt,name=mint_input,json=mintInput,proto3,oneof"`
}

type TokenTransaction_TransferInput struct {
	TransferInput *TokenTransferInput `protobuf:"bytes,3,opt,name=transfer_input,json=transferInput,proto3,oneof"`
}

func (*TokenTransaction_MintInput) isTokenTransaction_TokenInputs() {}

func (*TokenTransaction_TransferInput) isTokenTransaction_TokenInputs() {}

type SignatureWithIndex struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This is a Schnorr or ECDSA DER signature which can be between 64 and 73
	// bytes.
	Signature []byte `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty"`
	// The index of the TTXO associated with this signature.
	InputIndex    uint32 `protobuf:"varint,2,opt,name=input_index,json=inputIndex,proto3" json:"input_index,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SignatureWithIndex) Reset() {
	*x = SignatureWithIndex{}
	mi := &file_spark_token_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SignatureWithIndex) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignatureWithIndex) ProtoMessage() {}

func (x *SignatureWithIndex) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignatureWithIndex.ProtoReflect.Descriptor instead.
func (*SignatureWithIndex) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{5}
}

func (x *SignatureWithIndex) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *SignatureWithIndex) GetInputIndex() uint32 {
	if x != nil {
		return x.InputIndex
	}
	return 0
}

// A group of signatures for the input TTXOs binding them to the final token
// transaction hash. This bundle of signatures is specific to a given operator.
type InputTtxoSignaturesPerOperator struct {
	state                     protoimpl.MessageState `protogen:"open.v1"`
	TtxoSignatures            []*SignatureWithIndex  `protobuf:"bytes,1,rep,name=ttxo_signatures,json=ttxoSignatures,proto3" json:"ttxo_signatures,omitempty"`
	OperatorIdentityPublicKey []byte                 `protobuf:"bytes,2,opt,name=operator_identity_public_key,json=operatorIdentityPublicKey,proto3" json:"operator_identity_public_key,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *InputTtxoSignaturesPerOperator) Reset() {
	*x = InputTtxoSignaturesPerOperator{}
	mi := &file_spark_token_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InputTtxoSignaturesPerOperator) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InputTtxoSignaturesPerOperator) ProtoMessage() {}

func (x *InputTtxoSignaturesPerOperator) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InputTtxoSignaturesPerOperator.ProtoReflect.Descriptor instead.
func (*InputTtxoSignaturesPerOperator) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{6}
}

func (x *InputTtxoSignaturesPerOperator) GetTtxoSignatures() []*SignatureWithIndex {
	if x != nil {
		return x.TtxoSignatures
	}
	return nil
}

func (x *InputTtxoSignaturesPerOperator) GetOperatorIdentityPublicKey() []byte {
	if x != nil {
		return x.OperatorIdentityPublicKey
	}
	return nil
}

// === Start Transaction ===
type StartTransactionRequest struct {
	state                   protoimpl.MessageState `protogen:"open.v1"`
	IdentityPublicKey       []byte                 `protobuf:"bytes,1,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	PartialTokenTransaction *TokenTransaction      `protobuf:"bytes,2,opt,name=partial_token_transaction,json=partialTokenTransaction,proto3" json:"partial_token_transaction,omitempty"`
	// Filled by signing the partial token transaction hash with the
	// owner/issuer private key. For mint transactions this will be one
	// signature for the input issuer_public_key For transfer transactions this
	// will be one for each output for the output owner_public_key
	PartialTokenTransactionOwnerSignatures []*SignatureWithIndex `protobuf:"bytes,3,rep,name=partial_token_transaction_owner_signatures,json=partialTokenTransactionOwnerSignatures,proto3" json:"partial_token_transaction_owner_signatures,omitempty"`
	// How long the transaction should be valid for, in seconds.
	// The server will set the actual expiry_time in the final transaction based
	// on this duration. Must be between 1 and 300 seconds.
	ValidityDurationSeconds uint64 `protobuf:"varint,4,opt,name=validity_duration_seconds,json=validityDurationSeconds,proto3" json:"validity_duration_seconds,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *StartTransactionRequest) Reset() {
	*x = StartTransactionRequest{}
	mi := &file_spark_token_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartTransactionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartTransactionRequest) ProtoMessage() {}

func (x *StartTransactionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartTransactionRequest.ProtoReflect.Descriptor instead.
func (*StartTransactionRequest) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{7}
}

func (x *StartTransactionRequest) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

func (x *StartTransactionRequest) GetPartialTokenTransaction() *TokenTransaction {
	if x != nil {
		return x.PartialTokenTransaction
	}
	return nil
}

func (x *StartTransactionRequest) GetPartialTokenTransactionOwnerSignatures() []*SignatureWithIndex {
	if x != nil {
		return x.PartialTokenTransactionOwnerSignatures
	}
	return nil
}

func (x *StartTransactionRequest) GetValidityDurationSeconds() uint64 {
	if x != nil {
		return x.ValidityDurationSeconds
	}
	return 0
}

type StartTransactionResponse struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	FinalTokenTransaction *TokenTransaction      `protobuf:"bytes,1,opt,name=final_token_transaction,json=finalTokenTransaction,proto3" json:"final_token_transaction,omitempty"`
	KeyshareInfo          *spark.SigningKeyshare `protobuf:"bytes,2,opt,name=keyshare_info,json=keyshareInfo,proto3" json:"keyshare_info,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *StartTransactionResponse) Reset() {
	*x = StartTransactionResponse{}
	mi := &file_spark_token_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartTransactionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartTransactionResponse) ProtoMessage() {}

func (x *StartTransactionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartTransactionResponse.ProtoReflect.Descriptor instead.
func (*StartTransactionResponse) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{8}
}

func (x *StartTransactionResponse) GetFinalTokenTransaction() *TokenTransaction {
	if x != nil {
		return x.FinalTokenTransaction
	}
	return nil
}

func (x *StartTransactionResponse) GetKeyshareInfo() *spark.SigningKeyshare {
	if x != nil {
		return x.KeyshareInfo
	}
	return nil
}

type CommitTransactionRequest struct {
	state                          protoimpl.MessageState            `protogen:"open.v1"`
	FinalTokenTransaction          *TokenTransaction                 `protobuf:"bytes,1,opt,name=final_token_transaction,json=finalTokenTransaction,proto3" json:"final_token_transaction,omitempty"`
	FinalTokenTransactionHash      []byte                            `protobuf:"bytes,2,opt,name=final_token_transaction_hash,json=finalTokenTransactionHash,proto3" json:"final_token_transaction_hash,omitempty"`
	InputTtxoSignaturesPerOperator []*InputTtxoSignaturesPerOperator `protobuf:"bytes,3,rep,name=input_ttxo_signatures_per_operator,json=inputTtxoSignaturesPerOperator,proto3" json:"input_ttxo_signatures_per_operator,omitempty"`
	OwnerIdentityPublicKey         []byte                            `protobuf:"bytes,4,opt,name=owner_identity_public_key,json=ownerIdentityPublicKey,proto3" json:"owner_identity_public_key,omitempty"`
	unknownFields                  protoimpl.UnknownFields
	sizeCache                      protoimpl.SizeCache
}

func (x *CommitTransactionRequest) Reset() {
	*x = CommitTransactionRequest{}
	mi := &file_spark_token_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CommitTransactionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitTransactionRequest) ProtoMessage() {}

func (x *CommitTransactionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitTransactionRequest.ProtoReflect.Descriptor instead.
func (*CommitTransactionRequest) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{9}
}

func (x *CommitTransactionRequest) GetFinalTokenTransaction() *TokenTransaction {
	if x != nil {
		return x.FinalTokenTransaction
	}
	return nil
}

func (x *CommitTransactionRequest) GetFinalTokenTransactionHash() []byte {
	if x != nil {
		return x.FinalTokenTransactionHash
	}
	return nil
}

func (x *CommitTransactionRequest) GetInputTtxoSignaturesPerOperator() []*InputTtxoSignaturesPerOperator {
	if x != nil {
		return x.InputTtxoSignaturesPerOperator
	}
	return nil
}

func (x *CommitTransactionRequest) GetOwnerIdentityPublicKey() []byte {
	if x != nil {
		return x.OwnerIdentityPublicKey
	}
	return nil
}

type CommitTransactionResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CommitTransactionResponse) Reset() {
	*x = CommitTransactionResponse{}
	mi := &file_spark_token_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CommitTransactionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitTransactionResponse) ProtoMessage() {}

func (x *CommitTransactionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitTransactionResponse.ProtoReflect.Descriptor instead.
func (*CommitTransactionResponse) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{10}
}

var File_spark_token_proto protoreflect.FileDescriptor

const file_spark_token_proto_rawDesc = "" +
	"\n" +
	"\x11spark_token.proto\x12\vspark_token\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\vspark.proto\x1a\x17validate/validate.proto\"\x9b\x01\n" +
	"\x12TokenOutputToSpend\x12F\n" +
	"\x1bprev_token_transaction_hash\x18\x01 \x01(\fB\a\xfaB\x04z\x02h R\x18prevTokenTransactionHash\x12=\n" +
	"\x1bprev_token_transaction_vout\x18\x02 \x01(\rR\x18prevTokenTransactionVout\"_\n" +
	"\x12TokenTransferInput\x12I\n" +
	"\x10outputs_to_spend\x18\x01 \x03(\v2\x1f.spark_token.TokenOutputToSpendR\x0eoutputsToSpend\"\x81\x01\n" +
	"\x0eTokenMintInput\x123\n" +
	"\x11issuer_public_key\x18\x01 \x01(\fB\a\xfaB\x04z\x02h!R\x0fissuerPublicKey\x12:\n" +
	"\x19issuer_provided_timestamp\x18\x02 \x01(\x04R\x17issuerProvidedTimestamp\"\xdf\x03\n" +
	"\vTokenOutput\x12\x1d\n" +
	"\x02id\x18\x01 \x01(\tB\b\xfaB\x05r\x03\xb0\x01\x01H\x00R\x02id\x88\x01\x01\x121\n" +
	"\x10owner_public_key\x18\x02 \x01(\fB\a\xfaB\x04z\x02h!R\x0eownerPublicKey\x12A\n" +
	"\x15revocation_commitment\x18\x03 \x01(\fB\a\xfaB\x04z\x02h!H\x01R\x14revocationCommitment\x88\x01\x01\x121\n" +
	"\x12withdraw_bond_sats\x18\x04 \x01(\x04H\x02R\x10withdrawBondSats\x88\x01\x01\x12L\n" +
	" withdraw_relative_block_locktime\x18\x05 \x01(\x04H\x03R\x1dwithdrawRelativeBlockLocktime\x88\x01\x01\x121\n" +
	"\x10token_public_key\x18\x06 \x01(\fB\a\xfaB\x04z\x02h!R\x0etokenPublicKey\x12*\n" +
	"\ftoken_amount\x18\a \x01(\fB\a\xfaB\x04z\x02h\x10R\vtokenAmountB\x05\n" +
	"\x03_idB\x18\n" +
	"\x16_revocation_commitmentB\x15\n" +
	"\x13_withdraw_bond_satsB#\n" +
	"!_withdraw_relative_block_locktime\"\xd0\x03\n" +
	"\x10TokenTransaction\x12\x18\n" +
	"\aversion\x18\x01 \x01(\rR\aversion\x12<\n" +
	"\n" +
	"mint_input\x18\x02 \x01(\v2\x1b.spark_token.TokenMintInputH\x00R\tmintInput\x12H\n" +
	"\x0etransfer_input\x18\x03 \x01(\v2\x1f.spark_token.TokenTransferInputH\x00R\rtransferInput\x12=\n" +
	"\rtoken_outputs\x18\x04 \x03(\v2\x18.spark_token.TokenOutputR\ftokenOutputs\x12Z\n" +
	"#spark_operator_identity_public_keys\x18\x05 \x03(\fB\f\xfaB\t\x92\x01\x06\"\x04z\x02h!R\x1fsparkOperatorIdentityPublicKeys\x12;\n" +
	"\vexpiry_time\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"expiryTime\x122\n" +
	"\anetwork\x18\a \x01(\x0e2\x0e.spark.NetworkB\b\xfaB\x05\x82\x01\x02 \x00R\anetworkB\x0e\n" +
	"\ftoken_inputs\"^\n" +
	"\x12SignatureWithIndex\x12'\n" +
	"\tsignature\x18\x01 \x01(\fB\t\xfaB\x06z\x04\x10@\x18IR\tsignature\x12\x1f\n" +
	"\vinput_index\x18\x02 \x01(\rR\n" +
	"inputIndex\"\xb4\x01\n" +
	"\x1eInputTtxoSignaturesPerOperator\x12H\n" +
	"\x0fttxo_signatures\x18\x01 \x03(\v2\x1f.spark_token.SignatureWithIndexR\x0ettxoSignatures\x12H\n" +
	"\x1coperator_identity_public_key\x18\x02 \x01(\fB\a\xfaB\x04z\x02h!R\x19operatorIdentityPublicKey\"\xf2\x02\n" +
	"\x17StartTransactionRequest\x127\n" +
	"\x13identity_public_key\x18\x01 \x01(\fB\a\xfaB\x04z\x02h!R\x11identityPublicKey\x12Y\n" +
	"\x19partial_token_transaction\x18\x02 \x01(\v2\x1d.spark_token.TokenTransactionR\x17partialTokenTransaction\x12{\n" +
	"*partial_token_transaction_owner_signatures\x18\x03 \x03(\v2\x1f.spark_token.SignatureWithIndexR&partialTokenTransactionOwnerSignatures\x12F\n" +
	"\x19validity_duration_seconds\x18\x04 \x01(\x04B\n" +
	"\xfaB\a2\x05\x10\xac\x02 \x01R\x17validityDurationSeconds\"\xae\x01\n" +
	"\x18StartTransactionResponse\x12U\n" +
	"\x17final_token_transaction\x18\x01 \x01(\v2\x1d.spark_token.TokenTransactionR\x15finalTokenTransaction\x12;\n" +
	"\rkeyshare_info\x18\x02 \x01(\v2\x16.spark.SigningKeyshareR\fkeyshareInfo\"\xf8\x02\n" +
	"\x18CommitTransactionRequest\x12U\n" +
	"\x17final_token_transaction\x18\x01 \x01(\v2\x1d.spark_token.TokenTransactionR\x15finalTokenTransaction\x12H\n" +
	"\x1cfinal_token_transaction_hash\x18\x02 \x01(\fB\a\xfaB\x04z\x02h R\x19finalTokenTransactionHash\x12w\n" +
	"\"input_ttxo_signatures_per_operator\x18\x03 \x03(\v2+.spark_token.InputTtxoSignaturesPerOperatorR\x1einputTtxoSignaturesPerOperator\x12B\n" +
	"\x19owner_identity_public_key\x18\x04 \x01(\fB\a\xfaB\x04z\x02h!R\x16ownerIdentityPublicKey\"\x1b\n" +
	"\x19CommitTransactionResponse2\xde\x01\n" +
	"\x11SparkTokenService\x12b\n" +
	"\x11start_transaction\x12$.spark_token.StartTransactionRequest\x1a%.spark_token.StartTransactionResponse\"\x00\x12e\n" +
	"\x12commit_transaction\x12%.spark_token.CommitTransactionRequest\x1a&.spark_token.CommitTransactionResponse\"\x00B2Z0github.com/lightsparkdev/spark/proto/spark_tokenb\x06proto3"

var (
	file_spark_token_proto_rawDescOnce sync.Once
	file_spark_token_proto_rawDescData []byte
)

func file_spark_token_proto_rawDescGZIP() []byte {
	file_spark_token_proto_rawDescOnce.Do(func() {
		file_spark_token_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_spark_token_proto_rawDesc), len(file_spark_token_proto_rawDesc)))
	})
	return file_spark_token_proto_rawDescData
}

var file_spark_token_proto_msgTypes = make([]protoimpl.MessageInfo, 11)
var file_spark_token_proto_goTypes = []any{
	(*TokenOutputToSpend)(nil),             // 0: spark_token.TokenOutputToSpend
	(*TokenTransferInput)(nil),             // 1: spark_token.TokenTransferInput
	(*TokenMintInput)(nil),                 // 2: spark_token.TokenMintInput
	(*TokenOutput)(nil),                    // 3: spark_token.TokenOutput
	(*TokenTransaction)(nil),               // 4: spark_token.TokenTransaction
	(*SignatureWithIndex)(nil),             // 5: spark_token.SignatureWithIndex
	(*InputTtxoSignaturesPerOperator)(nil), // 6: spark_token.InputTtxoSignaturesPerOperator
	(*StartTransactionRequest)(nil),        // 7: spark_token.StartTransactionRequest
	(*StartTransactionResponse)(nil),       // 8: spark_token.StartTransactionResponse
	(*CommitTransactionRequest)(nil),       // 9: spark_token.CommitTransactionRequest
	(*CommitTransactionResponse)(nil),      // 10: spark_token.CommitTransactionResponse
	(*timestamppb.Timestamp)(nil),          // 11: google.protobuf.Timestamp
	(spark.Network)(0),                     // 12: spark.Network
	(*spark.SigningKeyshare)(nil),          // 13: spark.SigningKeyshare
}
var file_spark_token_proto_depIdxs = []int32{
	0,  // 0: spark_token.TokenTransferInput.outputs_to_spend:type_name -> spark_token.TokenOutputToSpend
	2,  // 1: spark_token.TokenTransaction.mint_input:type_name -> spark_token.TokenMintInput
	1,  // 2: spark_token.TokenTransaction.transfer_input:type_name -> spark_token.TokenTransferInput
	3,  // 3: spark_token.TokenTransaction.token_outputs:type_name -> spark_token.TokenOutput
	11, // 4: spark_token.TokenTransaction.expiry_time:type_name -> google.protobuf.Timestamp
	12, // 5: spark_token.TokenTransaction.network:type_name -> spark.Network
	5,  // 6: spark_token.InputTtxoSignaturesPerOperator.ttxo_signatures:type_name -> spark_token.SignatureWithIndex
	4,  // 7: spark_token.StartTransactionRequest.partial_token_transaction:type_name -> spark_token.TokenTransaction
	5,  // 8: spark_token.StartTransactionRequest.partial_token_transaction_owner_signatures:type_name -> spark_token.SignatureWithIndex
	4,  // 9: spark_token.StartTransactionResponse.final_token_transaction:type_name -> spark_token.TokenTransaction
	13, // 10: spark_token.StartTransactionResponse.keyshare_info:type_name -> spark.SigningKeyshare
	4,  // 11: spark_token.CommitTransactionRequest.final_token_transaction:type_name -> spark_token.TokenTransaction
	6,  // 12: spark_token.CommitTransactionRequest.input_ttxo_signatures_per_operator:type_name -> spark_token.InputTtxoSignaturesPerOperator
	7,  // 13: spark_token.SparkTokenService.start_transaction:input_type -> spark_token.StartTransactionRequest
	9,  // 14: spark_token.SparkTokenService.commit_transaction:input_type -> spark_token.CommitTransactionRequest
	8,  // 15: spark_token.SparkTokenService.start_transaction:output_type -> spark_token.StartTransactionResponse
	10, // 16: spark_token.SparkTokenService.commit_transaction:output_type -> spark_token.CommitTransactionResponse
	15, // [15:17] is the sub-list for method output_type
	13, // [13:15] is the sub-list for method input_type
	13, // [13:13] is the sub-list for extension type_name
	13, // [13:13] is the sub-list for extension extendee
	0,  // [0:13] is the sub-list for field type_name
}

func init() { file_spark_token_proto_init() }
func file_spark_token_proto_init() {
	if File_spark_token_proto != nil {
		return
	}
	file_spark_token_proto_msgTypes[3].OneofWrappers = []any{}
	file_spark_token_proto_msgTypes[4].OneofWrappers = []any{
		(*TokenTransaction_MintInput)(nil),
		(*TokenTransaction_TransferInput)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_spark_token_proto_rawDesc), len(file_spark_token_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   11,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_spark_token_proto_goTypes,
		DependencyIndexes: file_spark_token_proto_depIdxs,
		MessageInfos:      file_spark_token_proto_msgTypes,
	}.Build()
	File_spark_token_proto = out.File
	file_spark_token_proto_goTypes = nil
	file_spark_token_proto_depIdxs = nil
}
