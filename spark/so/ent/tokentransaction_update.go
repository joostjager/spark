// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
	"github.com/lightsparkdev/spark/so/ent/predicate"
	"github.com/lightsparkdev/spark/so/ent/schema/schematype"
	"github.com/lightsparkdev/spark/so/ent/tokencreate"
	"github.com/lightsparkdev/spark/so/ent/tokenmint"
	"github.com/lightsparkdev/spark/so/ent/tokenoutput"
	"github.com/lightsparkdev/spark/so/ent/tokentransaction"
)

// TokenTransactionUpdate is the builder for updating TokenTransaction entities.
type TokenTransactionUpdate struct {
	config
	hooks    []Hook
	mutation *TokenTransactionMutation
}

// Where appends a list predicates to the TokenTransactionUpdate builder.
func (ttu *TokenTransactionUpdate) Where(ps ...predicate.TokenTransaction) *TokenTransactionUpdate {
	ttu.mutation.Where(ps...)
	return ttu
}

// SetUpdateTime sets the "update_time" field.
func (ttu *TokenTransactionUpdate) SetUpdateTime(t time.Time) *TokenTransactionUpdate {
	ttu.mutation.SetUpdateTime(t)
	return ttu
}

// SetPartialTokenTransactionHash sets the "partial_token_transaction_hash" field.
func (ttu *TokenTransactionUpdate) SetPartialTokenTransactionHash(b []byte) *TokenTransactionUpdate {
	ttu.mutation.SetPartialTokenTransactionHash(b)
	return ttu
}

// SetFinalizedTokenTransactionHash sets the "finalized_token_transaction_hash" field.
func (ttu *TokenTransactionUpdate) SetFinalizedTokenTransactionHash(b []byte) *TokenTransactionUpdate {
	ttu.mutation.SetFinalizedTokenTransactionHash(b)
	return ttu
}

// SetOperatorSignature sets the "operator_signature" field.
func (ttu *TokenTransactionUpdate) SetOperatorSignature(b []byte) *TokenTransactionUpdate {
	ttu.mutation.SetOperatorSignature(b)
	return ttu
}

// ClearOperatorSignature clears the value of the "operator_signature" field.
func (ttu *TokenTransactionUpdate) ClearOperatorSignature() *TokenTransactionUpdate {
	ttu.mutation.ClearOperatorSignature()
	return ttu
}

// SetStatus sets the "status" field.
func (ttu *TokenTransactionUpdate) SetStatus(sts schematype.TokenTransactionStatus) *TokenTransactionUpdate {
	ttu.mutation.SetStatus(sts)
	return ttu
}

// SetNillableStatus sets the "status" field if the given value is not nil.
func (ttu *TokenTransactionUpdate) SetNillableStatus(sts *schematype.TokenTransactionStatus) *TokenTransactionUpdate {
	if sts != nil {
		ttu.SetStatus(*sts)
	}
	return ttu
}

// ClearStatus clears the value of the "status" field.
func (ttu *TokenTransactionUpdate) ClearStatus() *TokenTransactionUpdate {
	ttu.mutation.ClearStatus()
	return ttu
}

// SetCoordinatorPublicKey sets the "coordinator_public_key" field.
func (ttu *TokenTransactionUpdate) SetCoordinatorPublicKey(b []byte) *TokenTransactionUpdate {
	ttu.mutation.SetCoordinatorPublicKey(b)
	return ttu
}

// ClearCoordinatorPublicKey clears the value of the "coordinator_public_key" field.
func (ttu *TokenTransactionUpdate) ClearCoordinatorPublicKey() *TokenTransactionUpdate {
	ttu.mutation.ClearCoordinatorPublicKey()
	return ttu
}

// AddSpentOutputIDs adds the "spent_output" edge to the TokenOutput entity by IDs.
func (ttu *TokenTransactionUpdate) AddSpentOutputIDs(ids ...uuid.UUID) *TokenTransactionUpdate {
	ttu.mutation.AddSpentOutputIDs(ids...)
	return ttu
}

// AddSpentOutput adds the "spent_output" edges to the TokenOutput entity.
func (ttu *TokenTransactionUpdate) AddSpentOutput(t ...*TokenOutput) *TokenTransactionUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return ttu.AddSpentOutputIDs(ids...)
}

// AddCreatedOutputIDs adds the "created_output" edge to the TokenOutput entity by IDs.
func (ttu *TokenTransactionUpdate) AddCreatedOutputIDs(ids ...uuid.UUID) *TokenTransactionUpdate {
	ttu.mutation.AddCreatedOutputIDs(ids...)
	return ttu
}

// AddCreatedOutput adds the "created_output" edges to the TokenOutput entity.
func (ttu *TokenTransactionUpdate) AddCreatedOutput(t ...*TokenOutput) *TokenTransactionUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return ttu.AddCreatedOutputIDs(ids...)
}

// SetMintID sets the "mint" edge to the TokenMint entity by ID.
func (ttu *TokenTransactionUpdate) SetMintID(id uuid.UUID) *TokenTransactionUpdate {
	ttu.mutation.SetMintID(id)
	return ttu
}

// SetNillableMintID sets the "mint" edge to the TokenMint entity by ID if the given value is not nil.
func (ttu *TokenTransactionUpdate) SetNillableMintID(id *uuid.UUID) *TokenTransactionUpdate {
	if id != nil {
		ttu = ttu.SetMintID(*id)
	}
	return ttu
}

// SetMint sets the "mint" edge to the TokenMint entity.
func (ttu *TokenTransactionUpdate) SetMint(t *TokenMint) *TokenTransactionUpdate {
	return ttu.SetMintID(t.ID)
}

// SetCreateID sets the "create" edge to the TokenCreate entity by ID.
func (ttu *TokenTransactionUpdate) SetCreateID(id uuid.UUID) *TokenTransactionUpdate {
	ttu.mutation.SetCreateID(id)
	return ttu
}

// SetNillableCreateID sets the "create" edge to the TokenCreate entity by ID if the given value is not nil.
func (ttu *TokenTransactionUpdate) SetNillableCreateID(id *uuid.UUID) *TokenTransactionUpdate {
	if id != nil {
		ttu = ttu.SetCreateID(*id)
	}
	return ttu
}

// SetCreate sets the "create" edge to the TokenCreate entity.
func (ttu *TokenTransactionUpdate) SetCreate(t *TokenCreate) *TokenTransactionUpdate {
	return ttu.SetCreateID(t.ID)
}

// Mutation returns the TokenTransactionMutation object of the builder.
func (ttu *TokenTransactionUpdate) Mutation() *TokenTransactionMutation {
	return ttu.mutation
}

// ClearSpentOutput clears all "spent_output" edges to the TokenOutput entity.
func (ttu *TokenTransactionUpdate) ClearSpentOutput() *TokenTransactionUpdate {
	ttu.mutation.ClearSpentOutput()
	return ttu
}

// RemoveSpentOutputIDs removes the "spent_output" edge to TokenOutput entities by IDs.
func (ttu *TokenTransactionUpdate) RemoveSpentOutputIDs(ids ...uuid.UUID) *TokenTransactionUpdate {
	ttu.mutation.RemoveSpentOutputIDs(ids...)
	return ttu
}

// RemoveSpentOutput removes "spent_output" edges to TokenOutput entities.
func (ttu *TokenTransactionUpdate) RemoveSpentOutput(t ...*TokenOutput) *TokenTransactionUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return ttu.RemoveSpentOutputIDs(ids...)
}

// ClearCreatedOutput clears all "created_output" edges to the TokenOutput entity.
func (ttu *TokenTransactionUpdate) ClearCreatedOutput() *TokenTransactionUpdate {
	ttu.mutation.ClearCreatedOutput()
	return ttu
}

// RemoveCreatedOutputIDs removes the "created_output" edge to TokenOutput entities by IDs.
func (ttu *TokenTransactionUpdate) RemoveCreatedOutputIDs(ids ...uuid.UUID) *TokenTransactionUpdate {
	ttu.mutation.RemoveCreatedOutputIDs(ids...)
	return ttu
}

// RemoveCreatedOutput removes "created_output" edges to TokenOutput entities.
func (ttu *TokenTransactionUpdate) RemoveCreatedOutput(t ...*TokenOutput) *TokenTransactionUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return ttu.RemoveCreatedOutputIDs(ids...)
}

// ClearMint clears the "mint" edge to the TokenMint entity.
func (ttu *TokenTransactionUpdate) ClearMint() *TokenTransactionUpdate {
	ttu.mutation.ClearMint()
	return ttu
}

// ClearCreate clears the "create" edge to the TokenCreate entity.
func (ttu *TokenTransactionUpdate) ClearCreate() *TokenTransactionUpdate {
	ttu.mutation.ClearCreate()
	return ttu
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (ttu *TokenTransactionUpdate) Save(ctx context.Context) (int, error) {
	ttu.defaults()
	return withHooks(ctx, ttu.sqlSave, ttu.mutation, ttu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (ttu *TokenTransactionUpdate) SaveX(ctx context.Context) int {
	affected, err := ttu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (ttu *TokenTransactionUpdate) Exec(ctx context.Context) error {
	_, err := ttu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (ttu *TokenTransactionUpdate) ExecX(ctx context.Context) {
	if err := ttu.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (ttu *TokenTransactionUpdate) defaults() {
	if _, ok := ttu.mutation.UpdateTime(); !ok {
		v := tokentransaction.UpdateDefaultUpdateTime()
		ttu.mutation.SetUpdateTime(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (ttu *TokenTransactionUpdate) check() error {
	if v, ok := ttu.mutation.PartialTokenTransactionHash(); ok {
		if err := tokentransaction.PartialTokenTransactionHashValidator(v); err != nil {
			return &ValidationError{Name: "partial_token_transaction_hash", err: fmt.Errorf(`ent: validator failed for field "TokenTransaction.partial_token_transaction_hash": %w`, err)}
		}
	}
	if v, ok := ttu.mutation.FinalizedTokenTransactionHash(); ok {
		if err := tokentransaction.FinalizedTokenTransactionHashValidator(v); err != nil {
			return &ValidationError{Name: "finalized_token_transaction_hash", err: fmt.Errorf(`ent: validator failed for field "TokenTransaction.finalized_token_transaction_hash": %w`, err)}
		}
	}
	if v, ok := ttu.mutation.Status(); ok {
		if err := tokentransaction.StatusValidator(v); err != nil {
			return &ValidationError{Name: "status", err: fmt.Errorf(`ent: validator failed for field "TokenTransaction.status": %w`, err)}
		}
	}
	return nil
}

func (ttu *TokenTransactionUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := ttu.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(tokentransaction.Table, tokentransaction.Columns, sqlgraph.NewFieldSpec(tokentransaction.FieldID, field.TypeUUID))
	if ps := ttu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := ttu.mutation.UpdateTime(); ok {
		_spec.SetField(tokentransaction.FieldUpdateTime, field.TypeTime, value)
	}
	if value, ok := ttu.mutation.PartialTokenTransactionHash(); ok {
		_spec.SetField(tokentransaction.FieldPartialTokenTransactionHash, field.TypeBytes, value)
	}
	if value, ok := ttu.mutation.FinalizedTokenTransactionHash(); ok {
		_spec.SetField(tokentransaction.FieldFinalizedTokenTransactionHash, field.TypeBytes, value)
	}
	if value, ok := ttu.mutation.OperatorSignature(); ok {
		_spec.SetField(tokentransaction.FieldOperatorSignature, field.TypeBytes, value)
	}
	if ttu.mutation.OperatorSignatureCleared() {
		_spec.ClearField(tokentransaction.FieldOperatorSignature, field.TypeBytes)
	}
	if value, ok := ttu.mutation.Status(); ok {
		_spec.SetField(tokentransaction.FieldStatus, field.TypeEnum, value)
	}
	if ttu.mutation.StatusCleared() {
		_spec.ClearField(tokentransaction.FieldStatus, field.TypeEnum)
	}
	if ttu.mutation.ExpiryTimeCleared() {
		_spec.ClearField(tokentransaction.FieldExpiryTime, field.TypeTime)
	}
	if value, ok := ttu.mutation.CoordinatorPublicKey(); ok {
		_spec.SetField(tokentransaction.FieldCoordinatorPublicKey, field.TypeBytes, value)
	}
	if ttu.mutation.CoordinatorPublicKeyCleared() {
		_spec.ClearField(tokentransaction.FieldCoordinatorPublicKey, field.TypeBytes)
	}
	if ttu.mutation.SpentOutputCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   tokentransaction.SpentOutputTable,
			Columns: []string{tokentransaction.SpentOutputColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttu.mutation.RemovedSpentOutputIDs(); len(nodes) > 0 && !ttu.mutation.SpentOutputCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   tokentransaction.SpentOutputTable,
			Columns: []string{tokentransaction.SpentOutputColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttu.mutation.SpentOutputIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   tokentransaction.SpentOutputTable,
			Columns: []string{tokentransaction.SpentOutputColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if ttu.mutation.CreatedOutputCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   tokentransaction.CreatedOutputTable,
			Columns: []string{tokentransaction.CreatedOutputColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttu.mutation.RemovedCreatedOutputIDs(); len(nodes) > 0 && !ttu.mutation.CreatedOutputCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   tokentransaction.CreatedOutputTable,
			Columns: []string{tokentransaction.CreatedOutputColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttu.mutation.CreatedOutputIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   tokentransaction.CreatedOutputTable,
			Columns: []string{tokentransaction.CreatedOutputColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if ttu.mutation.MintCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   tokentransaction.MintTable,
			Columns: []string{tokentransaction.MintColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenmint.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttu.mutation.MintIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   tokentransaction.MintTable,
			Columns: []string{tokentransaction.MintColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenmint.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if ttu.mutation.CreateCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   tokentransaction.CreateTable,
			Columns: []string{tokentransaction.CreateColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokencreate.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttu.mutation.CreateIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   tokentransaction.CreateTable,
			Columns: []string{tokentransaction.CreateColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokencreate.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, ttu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{tokentransaction.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	ttu.mutation.done = true
	return n, nil
}

// TokenTransactionUpdateOne is the builder for updating a single TokenTransaction entity.
type TokenTransactionUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *TokenTransactionMutation
}

// SetUpdateTime sets the "update_time" field.
func (ttuo *TokenTransactionUpdateOne) SetUpdateTime(t time.Time) *TokenTransactionUpdateOne {
	ttuo.mutation.SetUpdateTime(t)
	return ttuo
}

// SetPartialTokenTransactionHash sets the "partial_token_transaction_hash" field.
func (ttuo *TokenTransactionUpdateOne) SetPartialTokenTransactionHash(b []byte) *TokenTransactionUpdateOne {
	ttuo.mutation.SetPartialTokenTransactionHash(b)
	return ttuo
}

// SetFinalizedTokenTransactionHash sets the "finalized_token_transaction_hash" field.
func (ttuo *TokenTransactionUpdateOne) SetFinalizedTokenTransactionHash(b []byte) *TokenTransactionUpdateOne {
	ttuo.mutation.SetFinalizedTokenTransactionHash(b)
	return ttuo
}

// SetOperatorSignature sets the "operator_signature" field.
func (ttuo *TokenTransactionUpdateOne) SetOperatorSignature(b []byte) *TokenTransactionUpdateOne {
	ttuo.mutation.SetOperatorSignature(b)
	return ttuo
}

// ClearOperatorSignature clears the value of the "operator_signature" field.
func (ttuo *TokenTransactionUpdateOne) ClearOperatorSignature() *TokenTransactionUpdateOne {
	ttuo.mutation.ClearOperatorSignature()
	return ttuo
}

// SetStatus sets the "status" field.
func (ttuo *TokenTransactionUpdateOne) SetStatus(sts schematype.TokenTransactionStatus) *TokenTransactionUpdateOne {
	ttuo.mutation.SetStatus(sts)
	return ttuo
}

// SetNillableStatus sets the "status" field if the given value is not nil.
func (ttuo *TokenTransactionUpdateOne) SetNillableStatus(sts *schematype.TokenTransactionStatus) *TokenTransactionUpdateOne {
	if sts != nil {
		ttuo.SetStatus(*sts)
	}
	return ttuo
}

// ClearStatus clears the value of the "status" field.
func (ttuo *TokenTransactionUpdateOne) ClearStatus() *TokenTransactionUpdateOne {
	ttuo.mutation.ClearStatus()
	return ttuo
}

// SetCoordinatorPublicKey sets the "coordinator_public_key" field.
func (ttuo *TokenTransactionUpdateOne) SetCoordinatorPublicKey(b []byte) *TokenTransactionUpdateOne {
	ttuo.mutation.SetCoordinatorPublicKey(b)
	return ttuo
}

// ClearCoordinatorPublicKey clears the value of the "coordinator_public_key" field.
func (ttuo *TokenTransactionUpdateOne) ClearCoordinatorPublicKey() *TokenTransactionUpdateOne {
	ttuo.mutation.ClearCoordinatorPublicKey()
	return ttuo
}

// AddSpentOutputIDs adds the "spent_output" edge to the TokenOutput entity by IDs.
func (ttuo *TokenTransactionUpdateOne) AddSpentOutputIDs(ids ...uuid.UUID) *TokenTransactionUpdateOne {
	ttuo.mutation.AddSpentOutputIDs(ids...)
	return ttuo
}

// AddSpentOutput adds the "spent_output" edges to the TokenOutput entity.
func (ttuo *TokenTransactionUpdateOne) AddSpentOutput(t ...*TokenOutput) *TokenTransactionUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return ttuo.AddSpentOutputIDs(ids...)
}

// AddCreatedOutputIDs adds the "created_output" edge to the TokenOutput entity by IDs.
func (ttuo *TokenTransactionUpdateOne) AddCreatedOutputIDs(ids ...uuid.UUID) *TokenTransactionUpdateOne {
	ttuo.mutation.AddCreatedOutputIDs(ids...)
	return ttuo
}

// AddCreatedOutput adds the "created_output" edges to the TokenOutput entity.
func (ttuo *TokenTransactionUpdateOne) AddCreatedOutput(t ...*TokenOutput) *TokenTransactionUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return ttuo.AddCreatedOutputIDs(ids...)
}

// SetMintID sets the "mint" edge to the TokenMint entity by ID.
func (ttuo *TokenTransactionUpdateOne) SetMintID(id uuid.UUID) *TokenTransactionUpdateOne {
	ttuo.mutation.SetMintID(id)
	return ttuo
}

// SetNillableMintID sets the "mint" edge to the TokenMint entity by ID if the given value is not nil.
func (ttuo *TokenTransactionUpdateOne) SetNillableMintID(id *uuid.UUID) *TokenTransactionUpdateOne {
	if id != nil {
		ttuo = ttuo.SetMintID(*id)
	}
	return ttuo
}

// SetMint sets the "mint" edge to the TokenMint entity.
func (ttuo *TokenTransactionUpdateOne) SetMint(t *TokenMint) *TokenTransactionUpdateOne {
	return ttuo.SetMintID(t.ID)
}

// SetCreateID sets the "create" edge to the TokenCreate entity by ID.
func (ttuo *TokenTransactionUpdateOne) SetCreateID(id uuid.UUID) *TokenTransactionUpdateOne {
	ttuo.mutation.SetCreateID(id)
	return ttuo
}

// SetNillableCreateID sets the "create" edge to the TokenCreate entity by ID if the given value is not nil.
func (ttuo *TokenTransactionUpdateOne) SetNillableCreateID(id *uuid.UUID) *TokenTransactionUpdateOne {
	if id != nil {
		ttuo = ttuo.SetCreateID(*id)
	}
	return ttuo
}

// SetCreate sets the "create" edge to the TokenCreate entity.
func (ttuo *TokenTransactionUpdateOne) SetCreate(t *TokenCreate) *TokenTransactionUpdateOne {
	return ttuo.SetCreateID(t.ID)
}

// Mutation returns the TokenTransactionMutation object of the builder.
func (ttuo *TokenTransactionUpdateOne) Mutation() *TokenTransactionMutation {
	return ttuo.mutation
}

// ClearSpentOutput clears all "spent_output" edges to the TokenOutput entity.
func (ttuo *TokenTransactionUpdateOne) ClearSpentOutput() *TokenTransactionUpdateOne {
	ttuo.mutation.ClearSpentOutput()
	return ttuo
}

// RemoveSpentOutputIDs removes the "spent_output" edge to TokenOutput entities by IDs.
func (ttuo *TokenTransactionUpdateOne) RemoveSpentOutputIDs(ids ...uuid.UUID) *TokenTransactionUpdateOne {
	ttuo.mutation.RemoveSpentOutputIDs(ids...)
	return ttuo
}

// RemoveSpentOutput removes "spent_output" edges to TokenOutput entities.
func (ttuo *TokenTransactionUpdateOne) RemoveSpentOutput(t ...*TokenOutput) *TokenTransactionUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return ttuo.RemoveSpentOutputIDs(ids...)
}

// ClearCreatedOutput clears all "created_output" edges to the TokenOutput entity.
func (ttuo *TokenTransactionUpdateOne) ClearCreatedOutput() *TokenTransactionUpdateOne {
	ttuo.mutation.ClearCreatedOutput()
	return ttuo
}

// RemoveCreatedOutputIDs removes the "created_output" edge to TokenOutput entities by IDs.
func (ttuo *TokenTransactionUpdateOne) RemoveCreatedOutputIDs(ids ...uuid.UUID) *TokenTransactionUpdateOne {
	ttuo.mutation.RemoveCreatedOutputIDs(ids...)
	return ttuo
}

// RemoveCreatedOutput removes "created_output" edges to TokenOutput entities.
func (ttuo *TokenTransactionUpdateOne) RemoveCreatedOutput(t ...*TokenOutput) *TokenTransactionUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return ttuo.RemoveCreatedOutputIDs(ids...)
}

// ClearMint clears the "mint" edge to the TokenMint entity.
func (ttuo *TokenTransactionUpdateOne) ClearMint() *TokenTransactionUpdateOne {
	ttuo.mutation.ClearMint()
	return ttuo
}

// ClearCreate clears the "create" edge to the TokenCreate entity.
func (ttuo *TokenTransactionUpdateOne) ClearCreate() *TokenTransactionUpdateOne {
	ttuo.mutation.ClearCreate()
	return ttuo
}

// Where appends a list predicates to the TokenTransactionUpdate builder.
func (ttuo *TokenTransactionUpdateOne) Where(ps ...predicate.TokenTransaction) *TokenTransactionUpdateOne {
	ttuo.mutation.Where(ps...)
	return ttuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (ttuo *TokenTransactionUpdateOne) Select(field string, fields ...string) *TokenTransactionUpdateOne {
	ttuo.fields = append([]string{field}, fields...)
	return ttuo
}

// Save executes the query and returns the updated TokenTransaction entity.
func (ttuo *TokenTransactionUpdateOne) Save(ctx context.Context) (*TokenTransaction, error) {
	ttuo.defaults()
	return withHooks(ctx, ttuo.sqlSave, ttuo.mutation, ttuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (ttuo *TokenTransactionUpdateOne) SaveX(ctx context.Context) *TokenTransaction {
	node, err := ttuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (ttuo *TokenTransactionUpdateOne) Exec(ctx context.Context) error {
	_, err := ttuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (ttuo *TokenTransactionUpdateOne) ExecX(ctx context.Context) {
	if err := ttuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (ttuo *TokenTransactionUpdateOne) defaults() {
	if _, ok := ttuo.mutation.UpdateTime(); !ok {
		v := tokentransaction.UpdateDefaultUpdateTime()
		ttuo.mutation.SetUpdateTime(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (ttuo *TokenTransactionUpdateOne) check() error {
	if v, ok := ttuo.mutation.PartialTokenTransactionHash(); ok {
		if err := tokentransaction.PartialTokenTransactionHashValidator(v); err != nil {
			return &ValidationError{Name: "partial_token_transaction_hash", err: fmt.Errorf(`ent: validator failed for field "TokenTransaction.partial_token_transaction_hash": %w`, err)}
		}
	}
	if v, ok := ttuo.mutation.FinalizedTokenTransactionHash(); ok {
		if err := tokentransaction.FinalizedTokenTransactionHashValidator(v); err != nil {
			return &ValidationError{Name: "finalized_token_transaction_hash", err: fmt.Errorf(`ent: validator failed for field "TokenTransaction.finalized_token_transaction_hash": %w`, err)}
		}
	}
	if v, ok := ttuo.mutation.Status(); ok {
		if err := tokentransaction.StatusValidator(v); err != nil {
			return &ValidationError{Name: "status", err: fmt.Errorf(`ent: validator failed for field "TokenTransaction.status": %w`, err)}
		}
	}
	return nil
}

func (ttuo *TokenTransactionUpdateOne) sqlSave(ctx context.Context) (_node *TokenTransaction, err error) {
	if err := ttuo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(tokentransaction.Table, tokentransaction.Columns, sqlgraph.NewFieldSpec(tokentransaction.FieldID, field.TypeUUID))
	id, ok := ttuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "TokenTransaction.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := ttuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, tokentransaction.FieldID)
		for _, f := range fields {
			if !tokentransaction.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != tokentransaction.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := ttuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := ttuo.mutation.UpdateTime(); ok {
		_spec.SetField(tokentransaction.FieldUpdateTime, field.TypeTime, value)
	}
	if value, ok := ttuo.mutation.PartialTokenTransactionHash(); ok {
		_spec.SetField(tokentransaction.FieldPartialTokenTransactionHash, field.TypeBytes, value)
	}
	if value, ok := ttuo.mutation.FinalizedTokenTransactionHash(); ok {
		_spec.SetField(tokentransaction.FieldFinalizedTokenTransactionHash, field.TypeBytes, value)
	}
	if value, ok := ttuo.mutation.OperatorSignature(); ok {
		_spec.SetField(tokentransaction.FieldOperatorSignature, field.TypeBytes, value)
	}
	if ttuo.mutation.OperatorSignatureCleared() {
		_spec.ClearField(tokentransaction.FieldOperatorSignature, field.TypeBytes)
	}
	if value, ok := ttuo.mutation.Status(); ok {
		_spec.SetField(tokentransaction.FieldStatus, field.TypeEnum, value)
	}
	if ttuo.mutation.StatusCleared() {
		_spec.ClearField(tokentransaction.FieldStatus, field.TypeEnum)
	}
	if ttuo.mutation.ExpiryTimeCleared() {
		_spec.ClearField(tokentransaction.FieldExpiryTime, field.TypeTime)
	}
	if value, ok := ttuo.mutation.CoordinatorPublicKey(); ok {
		_spec.SetField(tokentransaction.FieldCoordinatorPublicKey, field.TypeBytes, value)
	}
	if ttuo.mutation.CoordinatorPublicKeyCleared() {
		_spec.ClearField(tokentransaction.FieldCoordinatorPublicKey, field.TypeBytes)
	}
	if ttuo.mutation.SpentOutputCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   tokentransaction.SpentOutputTable,
			Columns: []string{tokentransaction.SpentOutputColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttuo.mutation.RemovedSpentOutputIDs(); len(nodes) > 0 && !ttuo.mutation.SpentOutputCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   tokentransaction.SpentOutputTable,
			Columns: []string{tokentransaction.SpentOutputColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttuo.mutation.SpentOutputIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   tokentransaction.SpentOutputTable,
			Columns: []string{tokentransaction.SpentOutputColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if ttuo.mutation.CreatedOutputCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   tokentransaction.CreatedOutputTable,
			Columns: []string{tokentransaction.CreatedOutputColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttuo.mutation.RemovedCreatedOutputIDs(); len(nodes) > 0 && !ttuo.mutation.CreatedOutputCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   tokentransaction.CreatedOutputTable,
			Columns: []string{tokentransaction.CreatedOutputColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttuo.mutation.CreatedOutputIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   tokentransaction.CreatedOutputTable,
			Columns: []string{tokentransaction.CreatedOutputColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if ttuo.mutation.MintCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   tokentransaction.MintTable,
			Columns: []string{tokentransaction.MintColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenmint.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttuo.mutation.MintIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   tokentransaction.MintTable,
			Columns: []string{tokentransaction.MintColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenmint.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if ttuo.mutation.CreateCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   tokentransaction.CreateTable,
			Columns: []string{tokentransaction.CreateColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokencreate.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttuo.mutation.CreateIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   tokentransaction.CreateTable,
			Columns: []string{tokentransaction.CreateColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokencreate.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &TokenTransaction{config: ttuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, ttuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{tokentransaction.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	ttuo.mutation.done = true
	return _node, nil
}
